/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from "three";
import React, { useRef, useState } from "react";
import { Html, useGLTF } from "@react-three/drei";
import { GLTF } from "three-stdlib";
import IcePlanetModel from "@/assets/3d/ice-planet.glb";
import { useFrame } from "@react-three/fiber";
import { useSpring, a } from "@react-spring/three";
import { ActivePlanet, usePlanetStore } from "@/stores/planet-store";
import { useNavigate } from "react-router-dom";

type GLTFResult = GLTF & {
  nodes: {
    baked: THREE.Mesh;
  };
  materials: {
    baked_planet: THREE.MeshStandardMaterial;
  };
};

interface Props {
  initial: React.JSX.IntrinsicElements["group"];
  rotationSpeed: number;
  position: THREE.Vector3;
  orbitRadius: number;
  orbitSpeed: number;
  tiltAngle: number;
  defaultScale: number;
}

export function IcePlanet({
  initial,
  rotationSpeed,
  orbitRadius,
  orbitSpeed,
  position,
  tiltAngle,
  defaultScale,
}: Props) {
  const { nodes, materials } = useGLTF(IcePlanetModel) as unknown as GLTFResult;

  const icePlanetRef = useRef<THREE.Group<THREE.Object3DEventMap>>(null);

  const theta = useRef(0);

  const tiltAxis = new THREE.Vector3(1, 1, 0).normalize();

  const zAngle = Math.PI / tiltAngle;

  const quaternion = new THREE.Quaternion().setFromAxisAngle(tiltAxis, zAngle);

  useFrame(() => {
    if (!icePlanetRef.current) return;

    //the rotation on its own axis
    icePlanetRef.current.rotation.y += rotationSpeed;

    if (isActive) return;

    //orbit
    theta.current = theta.current + orbitSpeed;

    const x = orbitRadius * Math.cos(theta.current) + position.x;
    const z = orbitRadius * Math.sin(theta.current) + position.z;

    const newVector3 = new THREE.Vector3(x, 0, z);

    newVector3.applyQuaternion(quaternion);

    const newPosition = new THREE.Vector3(
      newVector3.x + position.x,
      newVector3.y + position.y,
      newVector3.z + position.z
    );

    icePlanetRef.current.position.copy(newPosition);
  });

  const [isHovered, setIsHovered] = useState(false);

  const { scale } = useSpring({
    scale: isHovered ? defaultScale : defaultScale * 0.8,
    config: { tension: 100, friction: 30 },
  });

  const activePlanet = usePlanetStore((state) => state.activePlanet);

  const isActive = activePlanet === ActivePlanet.ICE;

  const setActivePlanet = usePlanetStore().setActivePlanet;

  const navigate = useNavigate();

  return (
    <a.group
      {...initial}
      dispose={null}
      ref={icePlanetRef}
      onPointerOver={(e: any) => {
        e.stopPropagation();
        setIsHovered(true);
        document.body.style.cursor = "pointer";
      }}
      onPointerLeave={(e: any) => {
        e.stopPropagation();
        setIsHovered(false);
        document.body.style.cursor = "auto";
      }}
      scale={scale}
      onClick={(e: any) => {
        e.stopPropagation();
        if (!icePlanetRef.current) return;
        const offset = 8;
        const targetPos = new THREE.Vector3().copy(
          icePlanetRef.current.position
        );

        targetPos.z += offset;

        setActivePlanet(ActivePlanet.ICE, targetPos);
      }}
    >
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.baked.geometry}
        material={materials.baked_planet}
        position={[0, 0, 0]}
      />
      {isActive && (
        <Html position={[0, 0, 0]} center distanceFactor={18}>
          <button
            className="p-2 text-center capitalize text-white bg-slate-600/40 rounded-xl min-w-40 backdrop-blur-xs"
            onClick={() => {
              navigate("/projects");
            }}
          >
            <h2 className="text-xl font-medium underline underline-offset-2">
              Projects:
            </h2>
            <p className="pb-2 mt-2 border-b-2 border-white/10">
              Check out my completed projects!
            </p>
            <p className="py-1 mt-1 text-xs">(click me again!)</p>
          </button>
        </Html>
      )}
    </a.group>
  );
}

useGLTF.preload(IcePlanetModel);
